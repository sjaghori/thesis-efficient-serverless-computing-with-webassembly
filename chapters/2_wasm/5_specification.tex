\section{WebAssembly Specification}
\label{sec:wasm-specification}

The Wasm standard is developed by W3C Working Group (WG) and W3C Community Group (CG) \cite{webassemblycommunitygroup_2023_webassembly}. The WebAssembly specification document \cite{webassemblycommunitygroup_2023_webassembly} focuses on Wasm's core Instruction Set Architecture layer, defining the instruction set, binary encoding, validation, execution semantics, and textual representation. However, it does not specify how WebAssembly programs interact with the execution environment or how they are invoked within that environment \cite{webassemblycommunitygroup_2023_webassembly}.

From creating a proposal to fully integrating it into WebAssembly core specification, it must process through several phases. Each proposal follows this progression \cite{webassemblyw3c_2023_webassembly}:
\begin{itemize}
  \item \textbf{0. Pre-Proposal [Individual]}: An individual files an issue on the design repository to discuss the idea. The idea is then discussed and championed by one or more members. 
  The proposal's general interest is voted on by the Community Group to ensure its scope and viability.
  \item \textbf{1. Feature Proposal [CG]}: A repository is created, and the champion works on reaching broad consensus within the Community Group. The design is iterated upon, and prototype implementations may be created to demonstrate the feature's viability.
  \item \textbf{2. Feature Description Available [CG + WG]}: A precise and complete overview document is produced with a high level of consensus. Prototype implementations create a comprehensive 
  test suite, but updates to the reference interpreter and spec document aren't yet required.
  \item \textbf{3. Implementation Phase [CG + WG]}: WebAssembly runtimes implement the feature, the spec document is updated with full English prose and formalization, and the reference interpreter is updated with a complete implementation. Toolchains implement the feature, and any remaining open questions are resolved.
  \item \textbf{4. Standardize the Feature [WG]}: The feature is handed over to the Working Group, which discusses the feature, considers edge cases, and confirms consensus on its completion. 
  The Working Group periodically polls on the feature's "ship-worthiness." If only minor changes are needed, they are made; otherwise, the feature is sent back to the Community Group.
  \item \textbf{5. The Feature is Standardized [WG]}: Once consensus is reached among Working Group members that the feature is complete, editors merge the feature into the main branch of the primary spec repository.
\end{itemize}

Throughout these phases, proposals are refined, adjusted, and tested to ensure their seamless integration with the existing WebAssembly specification. The following table \ref{tab:active-proposals} lists the active proposals and their current phase. The proposal repository \cite{webassemblywg_2023_webassembly} contains more information about each proposal, including the proposal's current phase, champion, and links to the proposal's repository and design document, furthermore, the repository also contains a list of all the proposals that have been merged into the WebAssembly core specification.

\input{tables/tab_active_proposals.tex}

\subsection{Multi-Value Return}
In modern programming languages that support tuples, like Kotlin, Rust or Python, developers can effortlessly bundle several values into a single structure for returning from a function. 
Simple tasks, such as switching a pair of values or sorting an array, become challenging since they must be performed within the linear memory block. 
Some arithmetic functions, including modular operations and carry bits, can also yield multiple values.

Apart from function return values, another limitation in the WebAssembly MVP is that instruction sequences, such as conditional blocks and loops, cannot consume or return more than one result. 
It would be equally intriguing to exchange values, perform arithmetic with overflow, or receive a multi-value tuple response in these scenarios as well. 
Furthermore, compilers are no longer required to jump through hoops when generating multiple stack values for core WebAssembly. This results in smaller generated bytecode and consequently, faster loading times and brings an extension type which is common in some programming languages like Rust or Python. Currently, the proposal has been already integrated into the WebAssembly core specification \cite{webassemblywg_2023_webassembly}. 

This proposal introduces a new type of arithmetic instruction "i32.divmod" which takes a numerator and divisor and returns the quotient and remainder. Moreover, it enables multiple values to stay on the stack without needing to be copied into linear memory.

The most effective way to demonstrate the proposal is by presenting a straightforward example. In example \ref{code:multi-values}, we have a WAT file with an exported function called "reverseSub" that subtracts the second parameter from the first one and returns the result. 

Firstly, we define a module that contains two functions. The first one is an internal function called "swap" that takes two i32 (32-bit integer) parameters and returns them in reverse order. The second function is the one that we want to export and is called "reverseSub". It takes two i32 parameters and returns an i32 value. An exported function, means it will be accessible outside the WebAssembly module. notice that "local.get 0" and "local.get 1" instructions are used to get the first and second parameters respectively. The "call \$swap" instruction calls the "swap" function and passes the two parameters to it. Finally, the "i32.sub" instruction subtracts the second parameter from the first one and returns the result.

\begin{lstlisting}[frame=lines, style=Wasm, caption={A reverse subtraction function that demonstrates the proposal for returning multiple values}, showstringspaces=false, captionpos=b, label=code:multi-values]
;; reverseSub.wat
(module
  (func $swap (param i32 i32) (result i32 i32)
    local.get 1
    local.get 0)

  (func (export "reverseSub") (param i32 i32) (result i32)
    local.get 0
    local.get 1
    call $swap
    i32.sub)
)
\end{lstlisting}

\subsection{Reference Types}
\label{subsec:reference-types}

Before the introduction of reference types, WebAssembly only supported four primitive value types: 32-bit integers, 64-bit integers, 32-bit floating-point numbers, and 64-bit floating-point numbers. With the introduction of reference types, WebAssembly capabilities are extended to include garbage-collected references. This will enable other proposals such as the garbage collection proposal, type import proposal \ref{tab:active-proposals} and more to utilize reference types without the need for glue code or dangerous workarounds. For instance the host stores objects in a side table and passes the indexes to the Wasm module. The Wasm module then uses these indexes to retrieve the objects from the side table. The usage of side tables requires glue code and is error-prone. Moreover, the glue code needs to be written in the host's language, making the Wasm module less portable.

The reference types proposal makes it possible for the host to specify and pass opaque handles to WebAssembly modules. These handles can be used to reference objects in the host environment, such as DOM nodes of a web page, a file handle or even open connection to a database. 

The reference types proposal brings three new features:
\begin{itemize}
    \item Makes it possible to have a \texttt{externref} type which is a opaque and unforgable reference to a object in the host environment.
    \item Makes it possible to store \texttt{externref} values in Wasm tables.
    \item Makes it possible to manipulate table entities with the help of new instructions.
\end{itemize}

As mentioned in the first bullet point, \texttt{externref} has two beneficial properties that fits the sandbox model of WebAssembly:
\begin{itemize}
    \item \textbf{Opaque}: The \texttt{externref} type is opaque, meaning that the reference does not reveal any significant information about the object it is referencing or the memory layout of the host environment.
    \item \textbf{Unforgable}: The \texttt{externref} type is unforgable, meaning it can either return a null reference or the same reference that was passed to the Wasm module. This prevents the Wasm module from creating new references to objects in the host environment. It makes it impossible to forge the reference. 
\end{itemize}

%TODO: Add example of how to use reference types


\section{Garbage Collector Proposal}
\label{sec:gc-proposals}

